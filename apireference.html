<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · JuliaDB</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaDB</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="apireference.html">API Reference</a><ul class="internal"><li><a class="toctext" href="#Loading-data-1">Loading data</a></li><li><a class="toctext" href="#Saving-and-Loading-tables-1">Saving and Loading tables</a></li><li><a class="toctext" href="#Compute-and-gather-1">Compute and gather</a></li><li><a class="toctext" href="#Indexing-1">Indexing</a></li><li><a class="toctext" href="#Queries-1">Queries</a></li><li><a class="toctext" href="#Joins-1">Joins</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apireference.html">API Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/docs/src/apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="API-documentation-1" href="#API-documentation-1">API documentation</a></h1><h2><a class="nav-anchor" id="Loading-data-1" href="#Loading-data-1">Loading data</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.ingest" href="#JuliaDB.ingest"><code>JuliaDB.ingest</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ingest(files::Union{AbstractVector,String}, outputdir::AbstractString; &lt;options&gt;...)</code></pre><p>ingests data from CSV files into JuliaDB. Stores the metadata and index in a directory <code>outputdir</code>. Creates <code>outputdir</code> if it doesn&#39;t exist.</p><p><strong>Arguments:</strong></p><ul><li><p><code>delim::Char</code>: the delimiter to use to read the text file with data. defaults to <code>,</code></p></li><li><p><code>indexcols::AbstractArray</code>: columns that are meant to act as the index for the table.  Defaults to all but the last column. If <code>datacols</code> is set, defaults to all  columns other than the data columns. If <code>indexcols</code> is an empty vector,  an implicit index of itegers <code>1:n</code> is added to the data.</p></li><li><p><code>datacols::AbstractArray</code>: columns that are meant to act as the data for the table.  Defaults to the last column. If <code>indexcols</code> is set, defaults to all  columns other than the index columns.</p></li><li><p><code>agg::Function</code>: aggregation function to use to combine data points with the same index. Defaults to nothing which leaves the data unaggregated (see <a href="apireference.html#IndexedTables.aggregate-Tuple{Any,JuliaDB.DTable}"><code>aggregate</code></a> to aggregate post-loading)).  table.)</p></li><li><p><code>presorted::Bool</code>: specifies if each CSV file is internally already sorted according  to the specified index column. This will avoid a re-sorting.</p></li><li><p><code>tomemory::Bool</code>: Load data to memory after ingesting instead of mmapping. Defaults to false.</p></li><li><p>The rest of the keyword arguments will be passed on to <a href="@ref"><code>TextParse.csvread</code></a> which is used by this function to load data from individual files.</p></li></ul><p>See also <a href="apireference.html#JuliaDB.loadfiles"><code>loadfiles</code></a> and <a href="apireference.html#JuliaDB.save"><code>save</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/ingest.jl#L5-L29">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.ingest!" href="#JuliaDB.ingest!"><code>JuliaDB.ingest!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ingest!(files::Union{AbstractVector,String}, outputdir::AbstractString; &lt;options&gt;...)</code></pre><p>ingest data from <code>files</code> and append into data stored in <code>outputdir</code>. Creates <code>outputdir</code> if it doesn&#39;t exist. Arguments are the same as those to <a href="@ref">ingest</a>. The index range of data in the new files should not overlap with files previously ingested.</p><p>See also <a href="@ingest"><code>ingest</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/ingest.jl#L42-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.loadfiles" href="#JuliaDB.loadfiles"><code>JuliaDB.loadfiles</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loadfiles(files::Union{AbstractVector,String}, delim = &#39;,&#39;; &lt;options&gt;)</code></pre><p>Load a collection of CSV <code>files</code> into a DTable, where <code>files</code> is either a vector of file paths, or the path of a directory containing files to load.</p><p><strong>Arguments:</strong></p><ul><li><p><code>usecache::Bool</code>: use cached metadata from previous loads while loading the files. Set this to <code>false</code> if you are changing other options.</p></li></ul><p>All other arguments options are the same as those listed in <a href="apireference.html#JuliaDB.ingest"><code>ingest</code></a>.</p><p>See also <a href="apireference.html#JuliaDB.ingest"><code>ingest</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/loadfiles.jl#L31-L44">source</a><br/></section><h2><a class="nav-anchor" id="Saving-and-Loading-tables-1" href="#Saving-and-Loading-tables-1">Saving and Loading tables</a></h2><p>Saving an existing <code>DTable</code> can be accomplished through the use of the <code>save</code> function.  The <code>save</code> function has the following help string:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.save" href="#JuliaDB.save"><code>JuliaDB.save</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">save(t::DTable, outputdir::AbstractString)</code></pre><p>Saves a <code>DTable</code> to disk. This function blocks till all files data has been computed and saved. Saved data can be loaded with <code>load</code>.</p><p>See also <a href="apireference.html#JuliaDB.ingest"><code>ingest</code></a>, <a href="apireference.html#JuliaDB.load"><code>load</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/ingest.jl#L158-L166">source</a><br/></section><p>Loading a previously saved <code>DTable</code> from disk can be accomplished through use of the <code>load</code> function.  The <code>load</code> function has the following help string:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.load" href="#JuliaDB.load"><code>JuliaDB.load</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">load(dir::AbstractString; tomemory)</code></pre><p>Load a saved <code>DTable</code> from <code>dir</code> directory. Data can be saved using <code>ingest</code> or <code>save</code> functions. If <code>tomemory</code> option is true, then data is loaded into memory rather than mmapped.</p><p>See also <a href="apireference.html#JuliaDB.ingest"><code>ingest</code></a>, <a href="apireference.html#JuliaDB.save"><code>save</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/ingest.jl#L139-L147">source</a><br/></section><h2><a class="nav-anchor" id="Compute-and-gather-1" href="#Compute-and-gather-1">Compute and gather</a></h2><p>Operations in JuliaDB are out-of-core in nature. They return <code>DTable</code> objects which can contain parts that are not yet evaluated. <code>compute</code> and <code>gather</code> are ways to force evaluation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.compute-Tuple{JuliaDB.DTable}" href="#Dagger.compute-Tuple{JuliaDB.DTable}"><code>Dagger.compute</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compute(t::DTable, allowoverlap=true)</code></pre><p>Computes any delayed-evaluations in the <code>DTable</code>. The computed data is left on the worker processes. Subsequent operations on the results will reuse the chunks.</p><p>If <code>allowoverlap</code> is false then the computed data is resorted to have no chunks with overlapping index ranges if necessary.</p><p>If you expect the result of some operation to be used more than once, it&#39;s better to compute it once and then use it many times.</p><p>See also <a href="apireference.html#Dagger.gather-Tuple{JuliaDB.DTable}"><code>gather</code></a>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>compute(t)</code> requires at least as much memory as the size of the result of the computing <code>t</code>. If the result is expected to be big, try <code>compute(save(t, &quot;output_dir&quot;))</code> instead. See <a href="apireference.html#JuliaDB.save"><code>save</code></a> for more.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/dtable.jl#L42-L61">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.gather-Tuple{JuliaDB.DTable}" href="#Dagger.gather-Tuple{JuliaDB.DTable}"><code>Dagger.gather</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gather(t::DTable)</code></pre><p>Gets distributed data in a DTable <code>t</code> and merges it into <a href="#IndexedTables.IndexedTable">IndexedTable</a> object</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>gather(t)</code> requires at least as much memory as the size of the result of the computing <code>t</code>. If the result is expected to be big, try <code>compute(save(t, &quot;output_dir&quot;))</code> instead. See <a href="apireference.html#JuliaDB.save"><code>save</code></a> for more. This data can be loaded later using <a href="apireference.html#JuliaDB.load"><code>load</code></a>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/dtable.jl#L77-L88">source</a><br/></section><h2><a class="nav-anchor" id="Indexing-1" href="#Indexing-1">Indexing</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{JuliaDB.DTable,Vararg{Any,N}}" href="#Base.getindex-Tuple{JuliaDB.DTable,Vararg{Any,N}}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">t[idx...]</code></pre><p>Returns a <code>DTable</code> containing only the elements of <code>t</code> where the given indices (<code>idx</code>) match. If <code>idx</code> has the same type as the index tuple of the <code>t</code>, then this is considered a scalar indexing (indexing of a single value). In this case the value itself is looked up and returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/indexing.jl#L2-L10">source</a><br/></section><h2><a class="nav-anchor" id="Queries-1" href="#Queries-1">Queries</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.select-Tuple{JuliaDB.DTable,Vararg{Pair,N}}" href="#Base.Sort.select-Tuple{JuliaDB.DTable,Vararg{Pair,N}}"><code>Base.Sort.select</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">select(t::DTable, conditions::Pair...)</code></pre><p>Filter based on index columns. Conditions are accepted as column-function pairs.</p><p>Example: <code>select(t, 1 =&gt; x-&gt;x&gt;10, 3 =&gt; x-&gt;x!=10 ...)</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/query.jl#L6-L12">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.select-Tuple{JuliaDB.DTable,Vararg{Union{Int64,Symbol},N}}" href="#Base.Sort.select-Tuple{JuliaDB.DTable,Vararg{Union{Int64,Symbol},N}}"><code>Base.Sort.select</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">select(t::DTable, which...; agg)</code></pre><p>Returns a new DTable where only a subset of the index columns (specified by <code>which</code>) are kept.</p><p>The <code>agg</code> keyword argument is a function which specifies how entries with equal indices should be aggregated. If <code>agg</code> is unspecified, then the repeating indices are kept in the output, you can then aggregate using <a href="apireference.html#IndexedTables.aggregate-Tuple{Any,JuliaDB.DTable}"><code>aggregate</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/query.jl#L17-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.aggregate-Tuple{Any,JuliaDB.DTable}" href="#IndexedTables.aggregate-Tuple{Any,JuliaDB.DTable}"><code>IndexedTables.aggregate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">aggregate(f, t::DTable)</code></pre><p>Combines adjacent rows with equal indices using the given 2-argument reduction function <code>f</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/query.jl#L50-L55">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.aggregate_vec-Tuple{Any,JuliaDB.DTable}" href="#IndexedTables.aggregate_vec-Tuple{Any,JuliaDB.DTable}"><code>IndexedTables.aggregate_vec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">aggregate_vec(f::Function, x::DTable)</code></pre><p>Combine adjacent rows with equal indices using a function from vector to scalar, e.g. <code>mean</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/query.jl#L64-L69">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter-Tuple{Any,JuliaDB.DTable}" href="#Base.filter-Tuple{Any,JuliaDB.DTable}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">filter(f, t::DTable)</code></pre><p>Filters <code>t</code> removing rows for which <code>f</code> is false. <code>f</code> is passed only the data and not the index.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/query.jl#L78-L83">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.convertdim-Tuple{JuliaDB.DTable,Union{Int64,Symbol},Any}" href="#IndexedTables.convertdim-Tuple{JuliaDB.DTable,Union{Int64,Symbol},Any}"><code>IndexedTables.convertdim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">convertdim(x::DTable, d::DimName, xlate; agg::Function, name)</code></pre><p>Apply function or dictionary <code>xlate</code> to each index in the specified dimension. If the mapping is many-to-one, <code>agg</code> is used to aggregate the results. <code>name</code> optionally specifies a name for the new dimension. <code>xlate</code> must be a monotonically increasing function.</p><p>See also <a href="apireference.html#Base.reducedim-Tuple{Any,JuliaDB.DTable,Any}"><code>reducedim</code></a> and <a href="apireference.html#IndexedTables.aggregate-Tuple{Any,JuliaDB.DTable}"><code>aggregate</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/query.jl#L88-L97">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reducedim-Tuple{Any,JuliaDB.DTable,Any}" href="#Base.reducedim-Tuple{Any,JuliaDB.DTable,Any}"><code>Base.reducedim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reducedim(f, t::DTable, dims)</code></pre><p>Remove <code>dims</code> dimensions from <code>t</code>, aggregate any rows with equal indices using 2-argument function <code>f</code>.</p><p>See also <a href="apireference.html#IndexedTables.reducedim_vec-Tuple{Any,JuliaDB.DTable,Any}"><code>reducedim_vec</code></a>, <a href="apireference.html#Base.Sort.select-Tuple{JuliaDB.DTable,Vararg{Pair,N}}"><code>select</code></a> and <a href="apireference.html#IndexedTables.aggregate-Tuple{Any,JuliaDB.DTable}"><code>aggregate</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/query.jl#L135-L142">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.reducedim_vec-Tuple{Any,JuliaDB.DTable,Any}" href="#IndexedTables.reducedim_vec-Tuple{Any,JuliaDB.DTable,Any}"><code>IndexedTables.reducedim_vec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reducedim_vec(f::Function, t::DTable, dims)</code></pre><p>Like <code>reducedim</code>, except uses a function mapping a vector of values to a scalar instead of a 2-argument scalar function.</p><p>See also <a href="apireference.html#Base.reducedim-Tuple{Any,JuliaDB.DTable,Any}"><code>reducedim</code></a> and <a href="apireference.html#IndexedTables.aggregate_vec-Tuple{Any,JuliaDB.DTable}"><code>aggregate_vec</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/query.jl#L153-L159">source</a><br/></section><h2><a class="nav-anchor" id="Joins-1" href="#Joins-1">Joins</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.naturaljoin-Tuple{JuliaDB.DTable,JuliaDB.DTable}" href="#IndexedTables.naturaljoin-Tuple{JuliaDB.DTable,JuliaDB.DTable}"><code>IndexedTables.naturaljoin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">naturaljoin(left::DTable, right::DTable, [op])</code></pre><p>Returns a new <code>DTable</code> containing only rows where the indices are present both in <code>left</code> AND <code>right</code> tables. The data columns are concatenated.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/join.jl#L5-L10">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.leftjoin-Tuple{JuliaDB.DTable{K,V},JuliaDB.DTable}" href="#IndexedTables.leftjoin-Tuple{JuliaDB.DTable{K,V},JuliaDB.DTable}"><code>IndexedTables.leftjoin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">leftjoin(left::DTable, right::DTable, [op::Function])</code></pre><p>Keeps only rows with indices in <code>left</code>. If rows of the same index are present in <code>right</code>, then they are combined using <code>op</code>. <code>op</code> by default picks the value from <code>right</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/join.jl#L84-L90">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.asofjoin-Tuple{JuliaDB.DTable,JuliaDB.DTable}" href="#IndexedTables.asofjoin-Tuple{JuliaDB.DTable,JuliaDB.DTable}"><code>IndexedTables.asofjoin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">asofjoin(left::DTable, right::DTable)</code></pre><p>Keeps the indices of <code>left</code> but uses the value from <code>right</code> corresponding to highest index less than or equal to that of left.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/join.jl#L127-L132">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge-Tuple{JuliaDB.DTable,JuliaDB.DTable}" href="#Base.merge-Tuple{JuliaDB.DTable,JuliaDB.DTable}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">merge(left::DTable, right::DTable; agg)</code></pre><p>Merges <code>left</code> and <code>right</code> combining rows with matching indices using <code>agg</code>. By default <code>agg</code> picks the value from <code>right</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9dcc91bba92a69bcc54ab7bca9fed757228944d0/src/join.jl#L137-L142">source</a><br/></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a></footer></article></body></html>
