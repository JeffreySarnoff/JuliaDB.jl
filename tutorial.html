<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · JuliaDB</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/jc.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaDB</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="tutorial.html">Tutorial</a><ul class="internal"><li><a class="toctext" href="#Construction-of-an-IndexedTable-1">Construction of an IndexedTable</a></li><li><a class="toctext" href="#Conversion-of-a-Local-IndexedTable-to-a-distributed-JuliaDB-Table-1">Conversion of a Local IndexedTable to a distributed JuliaDB Table</a></li><li><a class="toctext" href="#Importing-data-1">Importing data</a></li><li><a class="toctext" href="#Indexing-1">Indexing</a></li><li><a class="toctext" href="#Permuting-dimensions-1">Permuting dimensions</a></li><li><a class="toctext" href="#Select-and-aggregate-1">Select and aggregate</a></li><li><a class="toctext" href="#Converting-dimensions-1">Converting dimensions</a></li><li><a class="toctext" href="#Named-columns-1">Named columns</a></li></ul></li><li><a class="toctext" href="apireference.html">API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="tutorial.html">Tutorial</a></li></ul><a class="edit-page" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9e65f8c3b0e9c2e27c3334a093a5aefc6c7d1246/docs/src/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Using-JuliaDB-1" href="#Using-JuliaDB-1">Using JuliaDB</a></h1><h2><a class="nav-anchor" id="Construction-of-an-IndexedTable-1" href="#Construction-of-an-IndexedTable-1">Construction of an IndexedTable</a></h2><p>The <code>IndexedTable</code> constructor accepts a series of vectors. The last vector contains the data values, and the first N vectors contain the indices for each of the N dimensions. As an example, let&#39;s construct an array of the high temperatures for three days in two cities:</p><pre><code class="language-julia">julia&gt; using IndexedTables, JuliaDB

julia&gt; hitemps = IndexedTable([fill(&quot;New York&quot;,3); fill(&quot;Boston&quot;,3)],
                              repmat(Date(2016,7,6):Date(2016,7,8), 2),
                              [91,89,91,95,83,76])
───────────────────────┬───
&quot;Boston&quot;    2016-07-06 │ 95
&quot;Boston&quot;    2016-07-07 │ 83
&quot;Boston&quot;    2016-07-08 │ 76
&quot;New York&quot;  2016-07-06 │ 91
&quot;New York&quot;  2016-07-07 │ 89
&quot;New York&quot;  2016-07-08 │ 91</code></pre><p>Notice that the data was sorted first by city name, then date, giving a different order than we initially provided. On construction, <code>IndexedTable</code> takes ownership of the columns and sorts them in place (the original vectors are modified).</p><h2><a class="nav-anchor" id="Conversion-of-a-Local-IndexedTable-to-a-distributed-JuliaDB-Table-1" href="#Conversion-of-a-Local-IndexedTable-to-a-distributed-JuliaDB-Table-1">Conversion of a Local IndexedTable to a distributed JuliaDB Table</a></h2><p>One can convert an existing <code>IndexedTable</code> to a JuliaDB <code>DTable</code> through the use of the <code>distribute</code> function.</p><pre><code class="language-julia">julia&gt; dhitemps = distribute(hitemps, 2)
DTable with 6 rows in 2 chunks:

───────────────────────┬───
&quot;Boston&quot;    2016-07-06 │ 95
&quot;Boston&quot;    2016-07-07 │ 83
&quot;Boston&quot;    2016-07-08 │ 76
&quot;New York&quot;  2016-07-06 │ 91
&quot;New York&quot;  2016-07-07 │ 89
...</code></pre><p>The first argument provided to <code>distribute</code> is an existing <code>IndexedTable</code> and the second argument describes how the indexed table should be distributed amongst worker processes.  If the second argument is a scalar of value <code>n</code>, then the <code>IndexedTable</code> will be split into <code>n</code> approximately equal chunks across the worker processes.  If the second argument is a vector of n integers, then the distributed table with n separate chunks with each chunk having the number of rows present in each element of that vector.</p><h2><a class="nav-anchor" id="Importing-data-1" href="#Importing-data-1">Importing data</a></h2><h3><a class="nav-anchor" id="Reading-from-CSV-files-1" href="#Reading-from-CSV-files-1">Reading from CSV files</a></h3><p>Importing data from column-based sources is straightforward.  JuliaDB currently provides two distinct methods for importing data: <code>loadfiles</code> and <code>ingest</code>.  Both functions load the contents of one or more CSV files in a given directory and return a <code>DTable</code> of the loaded data.  The <code>ingest</code> function has the additional property of transforming the data into an efficient internal storage format, and saving both the original data and associated JuliaDB metadata to disk in a provided output directory.</p><p>The argument signature and help for <code>ingest</code> is the following:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.ingest" href="#JuliaDB.ingest"><code>JuliaDB.ingest</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ingest(files::Union{AbstractVector,String}, outputdir::AbstractString; &lt;options&gt;...)</code></pre><p>ingests data from CSV files into JuliaDB. Stores the metadata and index in a directory <code>outputdir</code>. Creates <code>outputdir</code> if it doesn&#39;t exist.</p><p><strong>Arguments:</strong></p><ul><li><p><code>delim::Char</code>: the delimiter to use to read the text file with data. defaults to <code>,</code></p></li><li><p><code>indexcols::AbstractArray</code>: columns that are meant to act as the index for the table.  Defaults to all but the last column. If <code>datacols</code> is set, defaults to all  columns other than the data columns. If <code>indexcols</code> is an empty vector,  an implicit index of itegers <code>1:n</code> is added to the data.</p></li><li><p><code>datacols::AbstractArray</code>: columns that are meant to act as the data for the table.  Defaults to the last column. If <code>indexcols</code> is set, defaults to all  columns other than the index columns.</p></li><li><p><code>agg::Function</code>: aggregation function to use to combine data points with the same index. Defaults to nothing which leaves the data unaggregated (see <a href="apireference.html#IndexedTables.aggregate-Tuple{Any,JuliaDB.DTable}"><code>aggregate</code></a> to aggregate post-loading)).  table.)</p></li><li><p><code>presorted::Bool</code>: specifies if each CSV file is internally already sorted according  to the specified index column. This will avoid a re-sorting.</p></li><li><p><code>tomemory::Bool</code>: Load data to memory after ingesting instead of mmapping. Defaults to false.</p></li><li><p>The rest of the keyword arguments will be passed on to <a href="@ref"><code>TextParse.csvread</code></a> which is used by this function to load data from individual files.</p></li></ul><p>See also <a href="tutorial.html#JuliaDB.loadfiles"><code>loadfiles</code></a> and <a href="tutorial.html#JuliaDB.save"><code>save</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9e65f8c3b0e9c2e27c3334a093a5aefc6c7d1246/src/ingest.jl#L5-L29">source</a><br/></section><p>The argument signature and help for <code>loadfiles</code> is the following:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.loadfiles" href="#JuliaDB.loadfiles"><code>JuliaDB.loadfiles</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loadfiles(files::Union{AbstractVector,String}, delim = &#39;,&#39;; &lt;options&gt;)</code></pre><p>Load a collection of CSV <code>files</code> into a DTable, where <code>files</code> is either a vector of file paths, or the path of a directory containing files to load.</p><p><strong>Arguments:</strong></p><ul><li><p><code>usecache::Bool</code>: use cached metadata from previous loads while loading the files. Set this to <code>false</code> if you are changing other options.</p></li></ul><p>All other arguments options are the same as those listed in <a href="tutorial.html#JuliaDB.ingest"><code>ingest</code></a>.</p><p>See also <a href="tutorial.html#JuliaDB.ingest"><code>ingest</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9e65f8c3b0e9c2e27c3334a093a5aefc6c7d1246/src/loadfiles.jl#L31-L44">source</a><br/></section><p>As stated above in the help text, each function has a set of optional input arguments that are specific to that particular function, as well as the ability to pass a set of trailing input arguments that are subsequently passed on to <a href="https://juliacomputing.com/TextParse.jl/stable/index.html#TextParse.csvread"><code>TextParse.csvread</code></a>.</p><p>An in-place variant of the <code>ingest!</code> function will append data from new files on to an existing <code>DTable</code> stored in a defined <code>outputdir</code>.  The help string for the in-place version of <code>ingest!</code> is the following:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.ingest!" href="#JuliaDB.ingest!"><code>JuliaDB.ingest!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ingest!(files::Union{AbstractVector,String}, outputdir::AbstractString; &lt;options&gt;...)</code></pre><p>ingest data from <code>files</code> and append into data stored in <code>outputdir</code>. Creates <code>outputdir</code> if it doesn&#39;t exist. Arguments are the same as those to <a href="@ref">ingest</a>. The index range of data in the new files should not overlap with files previously ingested.</p><p>See also <a href="@ingest"><code>ingest</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9e65f8c3b0e9c2e27c3334a093a5aefc6c7d1246/src/ingest.jl#L42-L50">source</a><br/></section><h3><a class="nav-anchor" id="Saving-and-Loading-existing-JuliaDB-DTables-1" href="#Saving-and-Loading-existing-JuliaDB-DTables-1">Saving and Loading existing JuliaDB DTables</a></h3><p>Saving an existing <code>DTable</code> can be accomplished through the use of the <code>save</code> function.  The <code>save</code> function has the following help string:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.save" href="#JuliaDB.save"><code>JuliaDB.save</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">save(t::DTable, outputdir::AbstractString)</code></pre><p>Saves a <code>DTable</code> to disk. This function blocks till all files data has been computed and saved. Saved data can be loaded with <code>load</code>.</p><p>See also <a href="tutorial.html#JuliaDB.ingest"><code>ingest</code></a>, <a href="tutorial.html#JuliaDB.load"><code>load</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9e65f8c3b0e9c2e27c3334a093a5aefc6c7d1246/src/ingest.jl#L158-L166">source</a><br/></section><p>Loading a previously saved <code>DTable</code> from disk can be accomplished through use of the <code>load</code> function.  The <code>load</code> function has the following help string:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.load" href="#JuliaDB.load"><code>JuliaDB.load</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">load(dir::AbstractString; tomemory)</code></pre><p>Load a saved <code>DTable</code> from <code>dir</code> directory. Data can be saved using <code>ingest</code> or <code>save</code> functions. If <code>tomemory</code> option is true, then data is loaded into memory rather than mmapped.</p><p>See also <a href="tutorial.html#JuliaDB.ingest"><code>ingest</code></a>, <a href="tutorial.html#JuliaDB.save"><code>save</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/tree/9e65f8c3b0e9c2e27c3334a093a5aefc6c7d1246/src/ingest.jl#L139-L147">source</a><br/></section><h2><a class="nav-anchor" id="Indexing-1" href="#Indexing-1">Indexing</a></h2><p>Most lookup and filtering operations on <code>DTable</code> are done via indexing. Our <code>dhitemps</code> array behaves like a 2-d array of integers, accepting two indices:</p><pre><code class="language-julia">julia&gt; dhitemps[&quot;Boston&quot;, Date(2016,7,8)]
76</code></pre><p>If the given indices exactly match the element types of the index columns, then the result is a scalar. In other cases, a new <code>DTable</code> is returned, giving data for all matching locations:</p><pre><code class="language-julia">julia&gt; dhitemps[&quot;Boston&quot;, :]
DTable with 1 chunks:

─────────────────────┬───
&quot;Boston&quot;  2016-07-06 │ 95
&quot;Boston&quot;  2016-07-07 │ 83
&quot;Boston&quot;  2016-07-08 │ 76
...</code></pre><h2><a class="nav-anchor" id="Permuting-dimensions-1" href="#Permuting-dimensions-1">Permuting dimensions</a></h2><p>As with other multi-dimensional arrays, dimensions can be permuted to change the sort order. With <code>DTable</code> the interpretation of this operation is especially natural: simply imagine passing the index columns to the constructor in a different order, and repeating the sorting process:</p><pre><code class="language-julia">julia&gt; permutedims(dhitemps, [2, 1])
DTable with 2 chunks:

───────────────────────┬───
2016-07-06  &quot;Boston&quot;   │ 95
2016-07-06  &quot;New York&quot; │ 91
2016-07-07  &quot;Boston&quot;   │ 83
2016-07-07  &quot;New York&quot; │ 89
2016-07-08  &quot;Boston&quot;   │ 76
...</code></pre><p>Now the data is sorted first by date. In some cases such dimension permutations are needed for performance. The leftmost column is esssentially the primary key –- indexing is fastest in this dimension.</p><h2><a class="nav-anchor" id="Select-and-aggregate-1" href="#Select-and-aggregate-1">Select and aggregate</a></h2><p>In some cases one wants to consider a subset of dimensions, for example when producing a simplified summary of data. This can be done by passing dimension (column) numbers (or names, as symbols) to <code>select</code>:</p><pre><code class="language-julia">julia&gt; select(dhitemps, 2)
DTable with 2 chunks:

───────────┬───
2016-07-06 │ 95
2016-07-06 │ 91
2016-07-07 │ 83
2016-07-07 │ 89
2016-07-08 │ 76
...</code></pre><p>In this case, the result has multiple values for some indices, and so does not fully behave like a normal array anymore. Operations that might leave the array in such a state accept the keyword argument <code>agg</code>, a function to use to combine all values associated with the same indices:</p><pre><code class="language-julia">julia&gt; select(dhitemps, 2, agg=max)
DTable with 2 chunks:

───────────┬───
2016-07-06 │ 95
2016-07-07 │ 89
2016-07-08 │ 91
...</code></pre><p>The aggregation operation can also be done by itself, in-place, using the function <code>aggregate!</code>.</p><p><code>select</code> also supports filtering columns with arbitrary predicates, by passing <code>column=&gt;predicate</code> pairs:</p><pre><code class="language-julia">julia&gt; select(dhitemps, 2=&gt;Dates.isfriday)
DTable with 2 chunks:

───────────────────────┬───
&quot;Boston&quot;    2016-07-08 │ 76
&quot;New York&quot;  2016-07-08 │ 91
...</code></pre><h2><a class="nav-anchor" id="Converting-dimensions-1" href="#Converting-dimensions-1">Converting dimensions</a></h2><p>A location in the coordinate space of an array often has multiple possible descriptions. This is especially common when describing data at different levels of detail. For example, a point in time can be expressed at the level of seconds, minutes, or hours. In our toy temperature dataset, we might want to look at monthly instead of daily highs.</p><p>This can be accomplished using the <code>convertdim</code> function. It accepts a DTable, a dimension number to convert, a function or dictionary to apply to indices in that dimension, and an aggregation function (the aggregation function is needed in case the mapping is many-to-one). The following call therefore gives monthly high temperatures:</p><pre><code class="language-julia">julia&gt; convertdim(dhitemps, 2, Dates.month, agg=max)
DTable with 2 chunks:

──────────────┬───
&quot;Boston&quot;    7 │ 95
&quot;New York&quot;  7 │ 91
...</code></pre><h2><a class="nav-anchor" id="Named-columns-1" href="#Named-columns-1">Named columns</a></h2><p><code>DTable</code> and <code>IndexedTable</code> are built on a simpler data structure called <code>Columns</code> that groups a set of vectors together. This structure is used to store the index part of an <code>IndexedTable</code>, and a <code>IndexedTable</code> can be constructed by passing one of these objects directly. <code>Columns</code> allows names to be associated with its constituent vectors. Together, these features allow <code>IndexedTable</code> and <code>DTable</code> arrays with named dimensions:</p><pre><code class="language-julia">julia&gt; hitemps = IndexedTable(Columns(city = [fill(&quot;New York&quot;,3); fill(&quot;Boston&quot;,3)],
                                      date = repmat(Date(2016,7,6):Date(2016,7,8), 2)),
                                      [91,89,91,95,83,76])
city        date       │
───────────────────────┼───
&quot;Boston&quot;    2016-07-06 │ 95
&quot;Boston&quot;    2016-07-07 │ 83
&quot;Boston&quot;    2016-07-08 │ 76
&quot;New York&quot;  2016-07-06 │ 91
&quot;New York&quot;  2016-07-07 │ 89
&quot;New York&quot;  2016-07-08 │ 91

julia&gt; dhitemps = distribute(hitemps,2)
DTable with 6 rows in 2 chunks:

city        date       │
───────────────────────┼───
&quot;Boston&quot;    2016-07-06 │ 95
&quot;Boston&quot;    2016-07-07 │ 83
&quot;Boston&quot;    2016-07-08 │ 76
&quot;New York&quot;  2016-07-06 │ 91
&quot;New York&quot;  2016-07-07 │ 89
...</code></pre><p>Now dimensions (e.g. in <code>select</code> operations) can be identified by symbol (e.g. <code>:city</code>) as well as integer index.</p><p>A <code>Columns</code> object itself behaves like a vector, and so can be used to represent the data part of a <code>DTable</code>. This provides one possible way to store multiple columns of data:</p><pre><code class="language-julia">julia&gt; t = IndexedTable(Columns(x = rand(4), y = rand(4)),
                        Columns(observation = rand(1:2,4), confidence = rand(4)))
x         y        │ observation  confidence
───────────────────┼────────────────────────
0.666683  0.193852 │ 2            0.707125
0.668276  0.136898 │ 2            0.519529
0.811008  0.511275 │ 2            0.0158134
0.977066  0.895341 │ 2            0.57636

julia&gt; dt = distribute(t, 2)
DTable with 4 rows in 2 chunks:

x         y        │ observation  confidence
───────────────────┼────────────────────────
0.666683  0.193852 │ 2            0.707125
0.668276  0.136898 │ 2            0.519529
0.811008  0.511275 │ 2            0.0158134
0.977066  0.895341 │ 2            0.57636</code></pre><p>In this case the data elements are structs with fields <code>observation</code> and <code>confidence</code>, and can be used as follows:</p><pre><code class="language-julia">julia&gt; filter(d-&gt;d.confidence &gt; 0.5, dt)
DTable with 2 chunks:

x         y        │ observation  confidence
───────────────────┼────────────────────────
0.666683  0.193852 │ 2            0.707125
0.668276  0.136898 │ 2            0.519529
0.977066  0.895341 │ 2            0.57636
...</code></pre><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="apireference.html"><span class="direction">Next</span><span class="title">API Reference</span></a></footer></article></body></html>
